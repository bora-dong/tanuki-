
■　2016/06/22

] V3.17

・razoring margin 0.1秒で12時間ほどチューンして、そのあと秒数を広げながらチューンしなおして、
　最終的に強くなったかどうかを長い持ち時間で検証する。



] V3.16

	PARAM_RAZORING_MARGIN4 : 554 → 570(53.16%) : ←←(値538,勝率50.97%,1872局,有意24.74%) ,←(値546,勝率50.20%,1872局,有意44.35%) ,→(値562,勝率51.41%,3744局,有意11.27%) ,→→(値570,勝率53.16%,1872局,有意1.36%) ,
	PARAM_RAZORING_MARGIN3 : 603 → 619(52.31%) : ←←(値587,勝率49.16%,3744局,有意76.42%) ,←(値595,勝率49.56%,1872局,有意62.28%) ,→(値611,勝率50.08%,1872局,有意47.72%) ,→→(値619,勝率52.31%,3744局,有意2.39%) ,
	PARAM_RAZORING_MARGIN2 : 570 → 578(51.59%) : ←←(値554,勝率49.84%,1872局,有意54.53%) ,←(値562,勝率49.19%,3744局,有意75.71%) ,→(値578,勝率51.59%,3744局,有意8.56%) ,→→(値586,勝率44.50%,624局,有意99.73%) ,
	PARAM_RAZORING_MARGIN1 : 483 → 483(50.00%) : ←←(値467,勝率49.84%,1872局,有意54.54%) ,←(値475,勝率50.24%,1872局,有意43.21%) ,→(値491,勝率50.73%,1872局,有意30.43%) ,→→(値499,勝率50.65%,1872局,有意32.44%) ,

	assert外しても速くならないな…。
	VS2015、assertのマクロ、除去出来ていない可能性が..

		秒読み3000[ms]

		54.3%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		107-5-90(10.0% R30.1)	

	静止探索のcheck_info_update()、元の位置に戻してなかった。

		秒読み10000[ms]

		44.8%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		125-11-154(96.4% R-36.2)	

	差は縮まってきた。npsさえ出れば魔女には勝っているのでは。
	20秒でもテストしておく。

		秒読み20000[ms]

		50.5%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		49-4-48(42.0% R3.6)	

	ほぼ互角のようだ。よしよし。

	gcc用、コンパイルしなおした。

		秒読み3000[ms]

		52.4%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		55-1-50(27.9% R16.6)	

	利きを求める部分以外はSSEなしでもなんとかなるかも知れないので、
	SSE2オプションを用意して準備をしていく。
	よく考えたらSSE4と4.1って別なのか。そうか…。
	SSE4用のオプションも用意する。
	これでSSE2用のバイナリがSSE2で動くかも。
	あとSSEなしでも動くかも。

	AperyのBitboardのoperator==()の実装、良くないのでGitHubで報告しておいた。

	EvalSumのnoSSE実装用意してなかった。用意する。
	というかUSE_AVX2でAVX2のコンストラクタ実装使っていなかった。
	
	EvalSum、eval/に移動。kppt_evalsumとリネーム

		VC++2015
		===========================
		Total time (ms) : 115619
		Nodes searched  : 72105321
		Nodes/second    : 623645

		gcc
		===========================
		Total time (ms) : 110433
		Nodes searched  : 72105321
		Nodes/second    : 652932

	やねうら王2016Mid、SSE42、SSE4、SSE2、noSSE用のバイナリも用意。

	ToDoより
	・ASSERT外してgccでビルドして2016 Midをリリース。
	→　した。
	・SSE2用バイナリを用意する。
	→　実験環境＆デバッグ環境がなくてよくわからない。
	→　とりあえずした。


■　2016/06/21

] V3.15

gcc 対応。__popcnt →　mm_popcnt_u64を使うと良いらしい。
	#include <nmmintrin.h>
	#define POPCNT32(a) _mm_popcnt_u64(a)
	#define POPCNT64(a) _mm_popcnt_u64(a)

		gcc
		===========================
		Total time (ms) : 128211
		Nodes searched  : 80011406
		Nodes/second    : 624060

		VC2015
		===========================
		Total time (ms) : 128684
		Nodes searched  : 80011406
		Nodes/second    : 621766

		何も変わってなかった。あれれ…。そして速くなっているな。
		FORCE_INLINEをつけた影響で少し速くなったのか？はてはて。

		BitboardのpopまわりにFORCE_INLINE追加した。
		movegen.cppにもFORCE_INLINE追加した。→　コンパイルがめっちゃ遅くなった。
		→　少し減らした。

		VC2015
		===========================
		Total time (ms) : 131980
		Nodes searched  : 80011406
		Nodes/second    : 606238

		gcc
		===========================
		Total time (ms) : 126935
		Nodes searched  : 80011406
		Nodes/second    : 630333

		gcc 仮想環境の外。4771
		===========================
		Total time (ms) : 122866
		Nodes searched  : 80011406
		Nodes/second    : 651208

		VC2015 仮想環境の外。4771
		===========================
		Total time (ms) : 125457
		Nodes searched  : 80011406
		Nodes/second    : 637759

		ASSERT外して、gccでコンパイルするか。
		gcc、もう少し速くなるかと思ったのだが…。


] V3.14

	1手0.5秒～3秒で簡単に調整できそうなパラメーターだけ自動調整してみる。
	調整したくないパラメーターはinterval = 9999に設定。

	まずはrazoring marginから。
	0.5秒で大雑把に調整して、そのあと秒数を増やしてみる。


		秒読み100[ms]

		50.4%	
		#227
		やねうら王2016mid V314slave
		slave。1スレッド
		#226
		やねうら王2016mid V314master
		master。1スレッド

		15558-418-15301(7.2% R2.9)	

	停止条件おかしくて止まってなかった。禿げる。



] V3.13

		秒読み400[ms]

		53.8%	
		#224
		やねうら王2016mid V313
		新基準。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		441-6-378(1.3% R26.8)	


	V3.13a
	search()でのevaluate()の呼び出しタイミング、やはり少し遅くしたほうが良いのでは..

		秒読み400[ms]

		48.8%	
		#225
		やねうら王2016mid V313a
		evaluate()遅延。1スレッド
		#224
		やねうら王2016mid V313
		新基準。1スレッド

		186-4-195(69.6% R-8.2)	

	計測不能な差のようなのでこれはいいや。



■　2016/06/20

] V3.12

	V3.12a
	 このkillerの設定、コメントアウトしたほうがいいかも。
	  {
        // IID、singular extension時であっても
        // killerがないときはkillerぐらいは登録したほうが少しだけ得。

        if (ss->killers[0] == MOVE_NONE)
          ss->killers[0] = move;
        else if (ss->killers[1] == MOVE_NONE)
          ss->killers[1] = move;
      }

		秒読み100[ms]

		54.7%	
		#222
		やねうら王2016mid V312a
		IID killerなし。1スレッド
		#221
		やねうら王2016mid V312
		新基準。1スレッド

		248-4-205(1.9% R33.1)	


		秒読み1000[ms]

		52.0%	
		#222
		やねうら王2016mid V312a
		IID killerなし。1スレッド
		#221
		やねうら王2016mid V312
		新基準。1スレッド

		640-27-591(8.1% R13.8)	

	IIDのkiller設定、よくないことがわかった。ばっさり消す。

	V3.12b
	・qsearch()を直接呼び出せるようにした。(学習で用いるので)
	書きかけ。まだ正しく動作しない。

	V3.12c
	ehashあり
		===========================
		Total time (ms) : 141850
		Nodes searched  : 80011406
		Nodes/second    : 564056

	ehashなし
		===========================
		Total time (ms) : 134267
		Nodes searched  : 80011406
		Nodes/second    : 595912

	なしのほうが速いっぽい。これは禿げる..。

	V3.12d
		if (!captureOrPawnPromotion && move != bestMove && quietCount < 64 - 4 + param1 * 4)
		param1 = 0..2
		10秒で魔女と回しておく。


		秒読み10000[ms]

		41.7%	38.6%	43.3%	
		#223
		やねうら王2016mid V312d
		quiet countテスト。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		123-17-172(99.8% R-58.2)	86-11-137(100.0% R-80.9)	97-10-127(98.1% R-46.8)	

		もう少しやらないと何とも…。


] V3.11

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
+      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
+      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。


	Core i7 4771k
	===========================
	Total time (ms) : 150870
	Nodes searched  : 92242005
	Nodes/second    : 611400


		秒読み1000[ms]

		59.5%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		94-5-64(0.7% R66.8)	


		秒読み3000[ms]

		41.4%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		96-10-136(99.7% R-60.5)	


	V3.11a
	historyでdropの+32をやめると？

		-      pc = Piece(pos.piece_on(sq) + (is_drop(move) ? 32 : 0));     \
		+      pc = Piece(pos.piece_on(sq) );     \

  Piece moved_piece_after_ex(Move m) const {
    return is_drop(m)
-      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) + 32)
+      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) /*+ 32*/)
      : is_promote(m) ? Piece(piece_on(move_from(m)) + PIECE_PROMOTE) : piece_on(move_from(m));
  }

-        Piece prevPc = pos.piece_on(prevSq) + Piece(is_drop((ss - 1)->currentMove) ? 32 : 0);
+       Piece prevPc = pos.piece_on(prevSq);


  これで互角なら、この処理なくしたい。
  Moveに移動させる駒が入っていれば、親nodeの移動させる駒が得られて、移動前の駒種でhistoryが
  引けて便利なのかも知れない。(cf. Apery)
  そこで強さに差が出ないなら、そのほうがシンプル。

		秒読み1000[ms]

		48.6%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		297-13-314(76.7% R-9.7)	

	誤差ぐらい。ここでわずかに良くとも、CPU cache汚染とかの問題があるので
	誤差ぐらいしか変わらないなら採用したくないのだが…。

		秒読み3000[ms]

		49.7%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		292-17-295(56.6% R-1.8)	

	ほぼ誤差だな。これは削除すべきか。そうか。

		  // 直前のnodeの指し手で動かした駒(移動後の駒)とその移動先の升を返す。
		  // この実装においてmoved_piece()は使えない。これは現在のPosition::side_to_move()の駒が返るからである。
		  // 駒打ちのときは、駒打ちの駒(+32した駒)が返る。
		#define sq_pc_from_move(sq,pc,move)                                \
			{                                                              \
			  sq = move_to(move);                                          \
			  pc = Piece(pos.piece_on(sq);     \
			}

	V3.11b
	ソースコード整理して、やねうら王2016 MidではUSE_DROPBIT_IN_STATSを使わないようにした。
	以前のバージョンより弱くなっていないかをテスト。

	history、移動前の駒で評価しても棋力変わらないのかも。
	指し手生成のときにmoveの上位bitを移動後の駒にするのは難しくはないのだが。
	というか、成りはquietではないのでhistoryからそもそも除外されているのか？
	除外は歩の成りだけか。うーん。角とか飛車の成り、本当に除外していいのか？
	価値上昇値が、歩の成りよりは低いか。	

		秒読み3000[ms]

		42.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		110-3-149(99.4% R-52.7)	

	あれ？めっちゃ弱くなった。どうなってんの…。

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。

	この省略が得していない？
	ああ、mate1ply()、置換表にhitしたときに省略されるのか。その差だな。
	修正して、再テスト。

		秒読み3000[ms]

		45.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		222-21-266(97.9% R-31.4)	

	やはり悪いのか…。そうなのか…。
	これは戻さざるをえない。

	V3.11c元に戻して0.3秒テスト。
	間違えてた。

		#ifndef USE_DROPBIT_IN_STATS   
			  pos.piece_on(prevSq);
		#else
			  pos.piece_on(prevSq) + Piece(is_drop((ss-1)->currentMove) ? 32 : 0);
		#endif

	こうだった。
	→　これで3.11と互角に戻った。再実験。

	V3.11d
		秒読み300[ms]

		48.3%	
		#214
		やねうら王2016mid V311d
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		703-21-752(90.1% R-11.7)	
	
	短い時間ではCPU cacheの汚染が少ないので勝ち越さなければならないのに
	勝っていないので、これは本当にダメそう。

	V3.11e
	MovePicker、killerの数に応じて、QUIET0,1,2,3とか分岐してはダメか？そこそこ意味があるような？
	Killer、Move32で持つの誤りだった。ExtMoveで持つべきだった。

		===========================
		Total time (ms) : 129748
		Nodes searched  : 74446076
		Nodes/second    : 573774

	比較実験しやすいようにdefineにする。

		// QUIETSの指し手を返すときに、分岐させて、少し高速化する。
		#define FAST_QUIETS

		===========================
		Total time (ms) : 130822
		Nodes searched  : 74446076
		Nodes/second    : 569063

	何も速くなってなかった。禿げた。
	killerまわり修正されたはずなのでV3.10と比較。

		秒読み300[ms]

		53.3%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		357-5-313(4.1% R22.8)	

		秒読み3000[ms]

		44.5%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-5-96(93.6% R-38.3)	
		あとはPGOとeval hashの差か。指し手生成で駒種格納。それからassert()消すと。


		秒読み10000[ms]

		44.7%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		209-28-259(99.1% R-37.3)	

		長い時間で勝率に差があったのは解消した。

	結論的には指し手生成段階で移動先での駒種 + 打ち駒なら32 をしたものを
	上位bitに格納したほうがいいのではということになった。

・moved_piece_after_exがいいどうか検討すべき。
	→　これやはり、それで正しい気がする。

	V3.11f
	aspirationのマージンを3秒で自動調整。

	        delta = Value(18 - 6 + 3 * param1);

	param1 = 0..4ぐらいで勝率を見る

		秒読み3000[ms]

		40.9%	46.8%	48.7%	47.4%	44.7%	
		#216
		やねうら王2016mid V311f
		aspiration調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		61-5-88(98.9% R-63.7)	36-1-41(75.3% R-22.6)	37-2-39(63.4% R-9.1)	36-2-40(71.7% R-18.3)	34-2-42(84.9% R-36.7)	

	V3.11g
	delta = Value(18 - 2 + 1 * param1);
	param1 = 0..4

		秒読み3000[ms]

		46.7%	48.0%	45.2%	51.3%	41.9%	
		#217
		やねうら王2016mid V311g
		aspiration調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		70-6-80(81.5% R-23.2)	72-6-78(71.6% R-13.9)	66-10-80(89.3% R-33.4)	78-4-74(34.3% R9.1)	62-4-86(98.0% R-56.8)	

	回数が少なくてよくわからない。


		// --- Counter Move

		// KEEP_PIECE_IN_COUNTER_MOVEがdefineされていたなら、
		// 移動させた駒を上位16bitに格納しておく。
		// bit24...16 = 移動させた駒(Piece。後手の駒含む)
		// bit15... 0 = 本来のMove

		#ifdef KEEP_PIECE_IN_COUNTER_MOVE
		#define COUNTER_MOVE Move32
		// 指し手の上位に駒種(移動前の駒)を格納してMove32化する。
		#define make_move32(move) ((Move32)((move) + (pos.moved_piece_after_ex(move) << 16)))
		#else
		#define COUNTER_MOVE Move 
		#endif

	このコード完全に削除して、Moveは32bit固定したほうがいいな。

		#ifndef KEEP_PIECE_IN_COUNTER_MOVE
			// しかし、Counter Moveの手は手番に関係ないので(駒種を保持していないなら)取り違える可能性があるため
			// (しかも、その可能性はそこそこ高い)、ここで合法性をチェックする必要がある。
			switch (pr)
			{
			case PAWN:
			case LANCE:
			  if ((us == BLACK && rank_of(to) == RANK_1) || (us == WHITE && rank_of(to) == RANK_9))
				return false;
			  break;
			case KNIGHT:
			  if ((us == BLACK && rank_of(to) < RANK_3) || (us == WHITE && rank_of(to) > RANK_7))
				return false;
			  break;
			}
		#else
			// 変な指し手を渡していないか、assertを入れて調べておく。(ASSERT_LV4以上のとき用)
			switch (pr)
			{
			case PAWN:
			case LANCE:
			  if ((us == BLACK && rank_of(to) == RANK_1) || (us == WHITE && rank_of(to) == RANK_9))
				ASSERT_LV4(false);
			  break;
			case KNIGHT:
			  if ((us == BLACK && rank_of(to) < RANK_3) || (us == WHITE && rank_of(to) > RANK_7))
				ASSERT_LV4(false);
			  break;
			}
		#endif

	V3.11h

	===========================
	Total time (ms) : 110191
	Nodes searched  : 62019533
	Nodes/second    : 562836

	何も速くなってない。なんなん…。

	まだいろいろ指し手生成にバグがあるようだ。
	random playerでデバッグ。

		#if 0
			  cout << pos;
			  for (auto m : mg)
			  {
				auto pc = pos.moved_piece_after_ex(m);
				cout << (Move)m << " " << pc << endl;
			  }
			  cout << endl;
		#endif

		  // ここで生成された指し手がすべて合法手であるかテストをする
		  for (auto m : mg)
		  {
			if (!pos.pseudo_legal(m))
			{
			  auto pc = pos.moved_piece_after_ex(m);
			  cout << pos << (Move)m << " " << pc;
			  pos.pseudo_legal(m);
			}

			ASSERT_LV3(pos.pseudo_legal(m));
			ASSERT_LV2(pos.legal(m));
		  }
		  →　やっとtest通った。

	===========================
	Total time (ms) : 185363
	Nodes searched  : 106442741
	Nodes/second    : 574239

	ほぼ高速化していないというのは指し手生成で余分なコストがかかった分を
	回収できていないのか。MovePickerはシンプルになったが…。

		秒読み100[ms]

		51.6%	
		#218
		やねうら王2016mid V311h
		指し手生成大改造。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		1079-34-1013(7.5% R11.0)	

	悪くはなっていなさそうなので良し。

	V3.11i
		piece_on()使っているところを置き換え。

	      Piece prevPc = pos.moved_piece_after_ex((ss - 1)->currentMove));

			秒読み100[ms]

			52.0%	
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド
			#210
			やねうら王2016mid V311
			新基準。1スレッド

			727-20-670(6.4% R14.2)	

	・clangでのコンパイル通るようにしてUbuntu×AWSで動くようにする。→　tanuki-さんにお願い中。
	→ 魔女ではgccでコンパイルするとVS2015でコンパイルするより15%ぐらい速くなる模様。
	→ gcc + PGOで1,2%ぐらい速くなる模様。VS2015のほうはちっとも..。
		gccでコンパイルしてリリースするか…。

	・classic-tceをビルドして、比較。
		classic-tceのほうがnpsが高い。
		Stockfish7でorderingがすこぶる重くなってnpsが下がったが、長い時間ではそちらのほうが良いようだ。

			秒読み100[ms]

			54.2%	
			#220
			やねうら王classic-tce V311i
			比較基準用。1スレッド
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド

			230-1-194(3.6% R29.6)	


			秒読み1000[ms]

			45.4%	
			#220
			やねうら王classic-tce V311i
			比較基準用。1スレッド
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド

			108-5-130(93.2% R-32.2)	



■　2016/06/18

] PGO

・PGOかける

	Visual Studio Community 2015でK-Shogiをビルドしてみた
	http://blog.studiok-i.net/shogi/1272.html

		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択 ※XXXはプロジェクト名
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – インストルメント」を選択
		リビルドする
		「デバッグ」メニュー ⇒ 「デバッグの開始」
		適当に動かす（最適化してほしいところを集中的に動かすとよい）
		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – 最適化」を選択
		ビルドする（リビルドではない）

	PGO前
	===========================
	Total time (ms) : 126895
	Nodes searched  : 79320741
	Nodes/second    : 625089

	PGO後
	===========================
	Total time (ms) : 124923
	Nodes searched  : 79320741
	Nodes/second    : 634957

	1%ほどしか変わらない。おかしい…。仮想環境だからな..

] V3.10

	・5,10秒で魔女と対戦

	5秒→10秒で勝率が低下する。長い持ち時間になったときに勝率が低下するファクターが
	まだ何か残っているのだと思う。静止探索での一手詰めとかあのへん怪しい。
	assert復活させてPGOなしにしてもう少し実験せねば。

		秒読み5000[ms]
		38.8%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		85-7-134(100.0% R-79.1)	


		秒読み10000[ms]
		32.9%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		199-28-406(100.0% R-123.9)	

	利き更新なし＋1手詰めなしにしたときの10秒での勝率とほぼ変わらない。
	静止探索での1手詰めが長い持ち時間において足を引っ張っている気がする。
	しかし、静止探索のオーバーヘッドだけでそんなに勝率が変わるとは考えにくいので
	他の要因があるはず。

	5秒対戦だとnpsの差で負けている可能性とかもあって、原因がよくわからない。
	10秒対戦での勝率を見ながらチューンするしかない。

		
	短い時間では静止探索での1手詰めの効果は顕著なのだが…。

		秒読み100[ms]

		43.9%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		723-24-923(100.0% R-42.4)	



	静止探索での1手詰めを入れないと弱くなった。
	やはり意味があるように思える。

		秒読み10000[ms]

		27.0%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		31-1-84(100.0% R-173.2)	


	まさかと思うがONE_PLY = 1で試す。
	そうか。futility margin、ONE_PLYで割られていないのでONE_PLY = 2でやっていると
	半分の値でやっていることになるのか…そうか…。
	ならStockfishのfutility margin = 200は100相当なので、わりといまの値に近いのか…。


		秒読み100[ms]

		45.1%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		352-13-429(99.7% R-34.4)	

	少し弱くなった。ONE_PLYの値に影響を受けている何かがあるのか…。
	PGOの差かも知れない。reduction table絡みかも知れない。

		秒読み500[ms]

		49.8%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		138-1-139(54.8% R-1.3)	

	500[ms]だとほぼ変わらずっぽいのでONE_PLY=1のままちょっといろいろいじる。

	V3.10c
	reduction量を変えてみる。

		  for (int imp = 0; imp <= 1; ++imp)
			for (int d = 1; d < 64; ++d)
			  for (int mc = 1; mc < 64; ++mc)
			  {
				double r = log(d) * log(mc) / 2;
				if (r < 0.80)
				  continue;

				reduction_table[NonPV][imp][d][mc] = int(std::round(r)) * ONE_PLY;
				reduction_table[PV][imp][d][mc] = std::max(reduction_table[NonPV][imp][d][mc] - ONE_PLY, DEPTH_ZERO);

				if (!imp && reduction_table[NonPV][imp][d][mc] >= 2 * ONE_PLY)
				  reduction_table[NonPV][imp][d][mc] += ONE_PLY;
			  }

	ONE_PLY = 1と2の差は関係なくて、reductionテーブルは後者のほうが理想に近いのが、
	長時間において差が出る要因なのだろう…。ONE_PLY = 2のほうが各種パラメーターを
	調整しやすいので良いはずなのだが、現状、そこまで細かく調整する価値のあるパラメーターが
	なくて、ONE_PLYで割るコストのほうが高くついているのかも知れない。

		秒読み500[ms]

		49.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		276-8-286(67.9% R-6.2)	

	ほぼ互角。3秒でも変わらなければこちらを採用したほうが良いのでは…。


		秒読み3000[ms]
		59.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		65-3-45(2.2% R63.9)	

	どうも長い時間では新しいreduction tableのほうが有利くさい。(もう少しやったほうが良い)
	長い時間で魔女と勝率に差があく原因の一つはこれなのか？

	魔女と5秒でやらせてみる。


		秒読み5000[ms]

		31.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		66-9-146(100.0% R-137.9)	

	前よりたくさん負け越した。そんな馬鹿な…。
	この際、魔女に近づけて行って、勝率どこで回復するか見たほうが良いのでは..

	V3.10d
	LMR新テーブル + qsearchでのmateなしとのコンボ。
	
		秒読み5000[ms]

		31.7%	
		#196
		やねうら王2016mid V310d
		ONE_PLY=1,reduction変更,qmateなし。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		33-2-71(100.0% R-133.1)	

	よく見たら魔女もqsearchでmate1呼んでた。置換表に書き出していないが…。

	V3.10e
	qmate復活。qmateのタイミングをもう少し早めに変更。
	mate1を見つけたときに置換表に書き出す処理、やめる。

		秒読み5000[ms]

		29.4%	
		#197
		やねうら王2016mid V310e
		qmate復活。呼び出しタイミング調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		55-5-132(100.0% R-152.1)	

	どんどん弱くなっててワロタ。


	V3.10f
	aspirationの幅40->18,深さ7->5

		秒読み5000[ms]

		34.4%	
		#198
		やねうら王2016mid V310f
		aspiration幅変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-8-147(100.0% R-112.3)	

	aspirationまわり変えたら、少し強くなった。
	そうか。Apery向けのaspirationではないので少し損をしていたのか…。

	Aperyのコード以下の部分、fall throughなのか。怖すぎワロタ。
		switch (pos.isDraw(16)) {
		case NotRepetition      : if (!Signals.stop.load(std::memory_order_relaxed) && ss->ply <= MaxPly) { break; }
		case RepetitionDraw     : return ScoreDraw;

	V3.10g
	update_stats()するの、capture or pawn promotionであるべき。

	V3.10h
	すべて↑であるべき。


		秒読み5000[ms]

		36.4%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		68-2-119(100.0% R-97.2)	

	R15ぐらい違うのかな？

		秒読み10000[ms]

		34.7%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		114-14-215(100.0% R-110.2)	

	10秒でもそんなにRは下がらなくなってきた。よしよし。


	USE_DROPBIT_IN_STATS、もしかして無駄である可能性…。
	まあいいや。いまそこが問題ではない。

	あとどこだろ。

	・指し手生成で何か抜けている可能性
	→　quiet + capture = all になるかとかテストすべき。

	・SEE()がおかしい可能性
	→　簡単な探索部と合致するかテストすべき

	・新しく書いたmate1ply()がおかしい可能性
	・評価関数が重い可能性
	
	V3.10i
	利き有効にしてのmate1ply()

		秒読み1000[ms]

		49.4%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		170-6-174(60.6% R-4.0)	


		秒読み3000[ms]

		42.0%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		42-4-58(95.6% R-56.1)	

	はやり遅い分だけやや損なのかも。

	see()書きなおしてみるか。

	V3.10j
	USE_SIMPLE_SEEを用意した。

		bench
		===========================
		Total time (ms) : 442722
		Nodes searched  : 308535061
		Nodes/second    : 696904

	だいぶ速くなった気がする。
	SEE、もう少し速くできる気がする。

		秒読み1000[ms]

		6.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		2-0-28(100.0% R-458.5)	

	20連敗した。SEE、これじゃない感。

	turn間違えてる。
	  Color turn = ~(is_drop(move) ? sideToMove : color_of(piece_on(move_from(move))));
	いま、seeの順番、金があとになってるのよくない気はする。
	あと、攻撃の有無間違えてた。あれだけでこんなに勝率下がるのか。そうか…。

		秒読み100[ms]

		22.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		20-0-68(100.0% R-212.6)	

	めっちゃ弱くなっとる。よく調べる。
	see()の前提処理まちごてた。修正した。

	see()前のコードも最後KING+1を返しているの、これおかしい気がしてきた。そうか…。
	と金で何かを取るとき、これがKING扱いになっていたのか。修正した。

		===========================
		Total time (ms) : 189502
		Nodes searched  : 108434227
		Nodes/second    : 572206

	
		秒読み300[ms]

		39.3%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		132-5-204(100.0% R-75.6)	

	新SEE、バグってるんやろか。元のSEEに戻してテスト。

	V3.10k

		秒読み300[ms]

		49.8%	
		#203
		やねうら王2016mid V310k
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		311-10-313(54.8% R-1.1)	

	SEE直したはずなのだが、勝率に影響がない。そんなもんなのか…。
	
	min_attacker()さらになおした。orderingも改善したはず…だが？

	V3.10l

		// 歩、香、桂、銀、金、角、飛…の順で取るのに使う駒を調べる。

		Bitboard b;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_PAWN  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_LANCE ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_KNIGHT][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_SILVER][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_GOLD  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm] | pos.king_square(stm)); if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm] | pos.king_square(stm)); if (b) goto found;

		// ここでサイクルは停止するのだ。
	#ifndef USE_SIMPLE_SEE
		uncapValue = VALUE_ZERO;
	#endif
		return KING;

	わりとわかりやすい気がする。


		秒読み300[ms]

		48.7%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		364-13-383(76.8% R-8.8)	

	わずかに遅くなった分、回収できていないのか…？

	// この駒が成れるなら、成りの値を返すべき。
	// ※　最後にこの地点に残る駒を返すべきなのか。相手が取る/取らないを選択するので。
	Piece pt = type_of(pos.piece_on(sq));
	if (!(pt & PIECE_PROMOTE) && (pt != GOLD)
		&& (canPromote(stm, to) || canPromote(stm,sq)))
		// 成りは敵陣へと、敵陣からの二種類あるので…。
	{

#ifndef USE_SIMPLE_SEE
		uncapValue = ProDiffPieceValue[pt]; // この駒が取り返せなかったときこの分、最後に損をする。
#endif
		return pt;
	}

	→　ちゃんと書いた。

		秒読み300[ms]

		50.0%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		525-19-524(48.8% R0.3)	

	やっと前のものと等価ぐらいになった。

	新see()なおってたりしないのか。
	V3.10m

		秒読み300[ms]

		41.8%	
		#205
		やねうら王2016mid V310m
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		147-5-205(99.9% R-57.8)	

	落ちなくはなったが弱い。まだ何かバグがある模様。
	まあいいや。これはまた時間あるときにデバッグしよう。
	
	V3.10n
	futility margin = 200など

		秒読み3000[ms]

		42.1%	
		#206
		やねうら王2016mid V310n
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		174-12-239(99.9% R-55.1)	

	差が縮まってきた…？

	V3.10o

	// 捕獲から逃れる指し手はreduction量を減らす。
	→　これ意味不明だった。どういうトリックかよくわからない。
	これ、コメントアウトしたほうがよさげ。
	see()の仕様がこちらの想定と違うのだが、それを考慮しても、
	Stockfishのコードはバグっているとしか思えない。

	null moveのreduction等を戻す。

		秒読み3000[ms]

		41.8%	
		#207
		やねうら王2016mid V310o
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		46-2-64(96.5% R-57.4)	


	V3.10p

-        pv[0] = MOVE_NONE;
+        (ss+1)->pv[0] = MOVE_NONE;

	なんぞこれ。間違えてた。

	魔女、fail lowたときに直前の指し手にボーナスを与える条件、間違っているような…。
		else if (depth >= 3 * OnePly
		  && bestMove.isNone() //!bestMove
		  && !inCheck
-		  && !ttMove.isCapture()//!move.cap()
+		  && !pos.captured_piece_type()
		  && (ss-1)->currentMove.is_ok())

	historyのupdateで打ち駒を+32してないところがあった。修正した。
	
	魔女より15%ぐらい遅いのかも知れない。(R40相当？)
	評価関数の差分計算とMoveの構造体、考えなおしたほうがよさ気。

		秒読み3000[ms]

		43.9%	
		#208
		やねうら王2016mid V310p
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		47-5-60(91.2% R-42.4)	

	npsの差程度に落ち着いてきた？寝る前に10秒で回しておく。
	せっかくなのでfutilityの幅を変える実験でもしておく。

	V3.10q
		  Value futility_margin(Depth d, int game_ply) {
			return Value(d * (PARAM_FUTILITY_MARGIN_ALPHA + param1 * 10 - 20) / ONE_PLY);
		  }

	Move32bit化、bit layout考えなおしたほうがよさ気。
	移動させる駒、上位16bitに格納するなら、駒打ちをそのbit5に格納したほうがいいような。
	historyで打ち駒を本当に分けたほうがいいのかはよくわからないが。
	historyにおいて、移動させる元の駒でorderingすべきなのか、そのあとの駒でorderingすべきか。
	指し手生成のときにそこまで生成すべきかどうか悩むな。


		秒読み10000[ms]

		41.1%	37.2%	37.5%	36.3%	39.6%	
		#209
		やねうら王2016mid V310q
		futility実験。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		129-18-185(99.9% R-62.6)	110-16-186(100.0% R-91.2)	112-13-187(100.0% R-89.0)	110-9-193(100.0% R-97.7)	120-9-183(100.0% R-73.3)	

	futility margin 180にしておくか。

