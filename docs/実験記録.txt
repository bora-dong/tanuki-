
■　2016/06/28

] V3.25

	・EVAL_KPPT_FAST

	V3.25a
	KPPT_FASTのdo_a_black/white()をVPGATHERDD化。ベンチ上、速くなったのかどうかすらわからない。
	gccでビルドしたほうはセグフォで落ちる。なんぞこれ。

	do_a_black/white()、玉が移動したときしか関係ないし、しかもおまけの処理だから、
	ここを高速化しても無駄であったか…。そうか…。

	VPGATHERDD自体がHaswellでは遅いのと、垂直addが効率良くないのと二重苦だな…。

		// これに相当する命令がない。簡単に書けない。
		u32 a32[8];
		_mm256_storeu_si256((__m256i*)&a32,data_sum);
		sum[0] = a32[0] + a32[4];
		sum[1] = a32[1] + a32[5];

	gcc、こう書いても落ちる。


		秒読み200[ms]

		50.0%	
		#260
		やねうら王2016late V325a
		evaluate() VPGATHERDD化
		#259
		やねうら王2016late V325
		新基準

		2331-68-2327(47.7% R0.3)	

	強くなってない。速くなってない。なにこれ。


	V3.25b
	玉が移動したときのΣKPPの片側を求めるのは、VPGATHERDDですこぶる効率的に書く方法を発見した。
	というか、思い出した。




■　2016/06/27

] V3.24

	・魔女の実行時間、プロファイラで調べる。
　	  →　調べるまでもなくevaluate()だわ。

	・KPPTの評価関数の差分計算、もう少し簡略化出来るかも。
 　	  →　いい方法思いついたので自分でやる。
	・評価関数のAVX2化。→　tanuki-さんにお願い中 →　評価関数に手番を入れてから →　AVX2化考える
 　	  →　いい方法思いついたので自分でやる。

	・to_sq()→sqww_to_sq()に変更。to_sq()をmove_to()のaliasに。

	V3.24a

	・KPPTのevaluate()高速化のためにソースコード整理していく。
	・Apery、魔女風にした。


		秒読み100[ms]

		52.9%	
		#257
		やねうら王2016mid V324a
		evaluate() リファクタリング
		#256
		やねうら王2016mid V324
		新基準。

		736-11-654(1.4% R20.5)	

	nps上がった分、少し強くなった可能性。

		gcc
		===========================
		Total time (ms) : 104813
		Nodes searched  : 69480659
		Nodes/second    : 662901


		秒読み15000[ms]

		51.1%	
		#258
		やねうら王2016mid V324a-gcc
		evaluate() リファクタリング
		#0
		silent_majority_V1.1公式
		1スレッド

		70-9-67(36.6% R7.6)	

	15秒で魔女に勝ち越したのは初めて。
	もう少し対局数をやったほうがいいが、長い時間だとマシンが長時間専有されて何とも…。
	まあ、互角ということでいいや。


■　2016/06/26

] V3.23

	V3.23a
	-    // IID、null move、singular extensionの判定のときは浅い探索なのでこのときに
	-    // killer等を更新するのは有害である。
	-    if (ss->skipEarlyPruning)
	-      return;
	
	これ、もはやないほうがいいのか…。


		// fail lowを引き起こした前nodeでのcounter moveに対してボーナスを加点する。
		else if (depth >= 3 * ONE_PLY
		  && !bestMove                        // bestMoveが無い == fail low
		  && !InCheck
		  && !pos.captured_piece_type()
		  && is_ok((ss - 1)->currentMove)
	-      && is_ok((ss - 2)->currentMove))
		{

	fail low bonusも修正したほうがいいな。

		秒読み300[ms]

		50.1%	
		#249
		やねうら王2016mid V323a
		update_stats()変更。
		#248
		やねうら王2016mid V323
		新基準

		578-21-576(47.7% R0.6)	

	短い時間において弱くはなっていないので採用。

	move_to → to_sq()にしたほうがStockfishと互換性が上がるのでは…。
	変な独自性出さないほうがいいような…。
	→　これはまだいいか..

	V3.23b
	ehash、bench値は上がらないが、2手前の局面で考えた結果が生きるので
	やったほうがいいのでは。有効にして比較する。

		秒読み300[ms]

		49.6%	
		#250
		やねうら王2016mid V323b
		ehash有効。
		#248
		やねうら王2016mid V323
		新基準

		408-16-414(59.6% R-2.5)	


		秒読み2000[ms]

		50.7%	
		#250
		やねうら王2016mid V323b
		ehash有効。
		#248
		やねうら王2016mid V323
		新基準

		106-5-103(39.1% R5.0)	


		→　よくわからない。スレッド数が多いなら他のスレッドの計算結果が使えていいのかも。
		互角ぐらいなら入れたい気はする。入れる。


	V3.23c
		-	PARAM_DEFINE PARAM_FUTILITY_AT_PARENT_NODE_MARGIN = 170;
		+	PARAM_DEFINE PARAM_FUTILITY_AT_PARENT_NODE_MARGIN = 256;
		いったん元に戻したほうが良いのでは..

			value = search<NonPV>(pos, ss, rBeta - 1, rBeta, depth * PARAM_SINGULAR_SEARCH_DEPTH / 256, cutNode);
			ss->skipEarlyPruning = false;
			ss->excludedMove = MOVE_NONE;

		-	ss->moveCount = moveCount; // 破壊したと思うので修復しておく。


		  if (givesCheck
		-	&& moveCount == 1
		+	&& !moveCountPruning
			&& pos.see_sign(move) >= VALUE_ZERO)
			extension = ONE_PLY;


			else if (depth >= 3 * ONE_PLY
			  && !bestMove                        // bestMoveが無い == fail low
		-	  && !InCheck
			  && !pos.captured_piece_type()
			  && is_ok((ss - 1)->currentMove))
			{
			  // 指し手のなかに移動後の駒が格納されているのでこれで取得できる。
			  Piece prevPc = pos.moved_piece_after((ss - 1)->currentMove);

		  if (  givesCheck
			-   && moveCount == 1
	   		+	&& !moveCountPruning
			&&  pos.see_sign(move) >= VALUE_ZERO)
			extension = ONE_PLY;

			これやはり、やりすぎであったか…。

				秒読み1000[ms]

				53.3%	
				#251
				やねうら王2016mid V323c
				see parant nodeでのmargin変更など。
				#248
				やねうら王2016mid V323
				新基準

				313-11-274(4.9% R23.1)	

			少し上がったか。

	V3.23d
			  // 捕獲する指し手か、歩の成りの指し手であるかを返す。
			  bool capture_or_pawn_promotion(Move m) const
			  {
	+		#ifdef KEEP_PIECE_IN_GENERATE_MOVES
	+			// 移動させる駒が歩かどうかは、Moveの上位16bitを見れば良い
	+			return (is_promote(m) && raw_type_of(moved_piece_after(m)) == PAWN) || capture(m);
	+		#else
				return (is_promote(m) && type_of(piece_on(move_from(m)))==PAWN) || capture(m);
	+		#endif
			  }

			少し高速化。


			null moveのとき、stateEval + 2*Tempo、良くないのでは..

	-		  if ((ss - 1)->currentMove == MOVE_NULL)
	-		    eval = ss->staticEval = -(ss - 1)->staticEval + 2 * Tempo;

	-		ss->staticEval = bestValue =
	-		  (ss - 1)->currentMove != MOVE_NULL ? evaluate(pos)
			                                     : -(ss - 1)->staticEval + 2 * Tempo;
	+		ss->staticEval = bestValue = evaluate(pos);

			秒読み300[ms]

			45.1%	
			#252
			やねうら王2016mid V323d
			null moveのときのevaluate()変更。
			#251
			やねうら王2016mid V323c
			see parant nodeでのmargin変更など。

			246-8-299(99.0% R-33.9)	

			なぜか弱くなった。npsも少し落ちたような感じ。
			null move、なんでこんななるのん..。

	+	  // この処理、入れたほうがいいようだ。一見するとevaluate()は上で手番つきで求めているから
	+	  // これをやると不正確になるだけのようであるが、null moveした局面で手番つきの評価関数を呼ぶと
	+	  // 駒に当たっているものがプラス評価されて、評価値として大きく出すぎて悪作用があるようだ。

		という結論になった。


		魔女公式と比較。


			秒読み3000[ms]

			50.5%	
			#254
			やねうら王2016mid V323e gcc
			戻した。
			#0
			silent_majority_V1.1公式
			1スレッド

			204-10-200(40.2% R3.4)	


	V3.23f
	test gensfenコマンドのデバッグ中に気づいたが、
	金相当のMoveの上位16bitに駒を金としていたのでこれがkillerとかcountermoveになったときは
	非合法手と扱いになるバグがあるようだ。

		  auto from = pieces.pop();
		  // fromの升にある駒をfromの升においたときの利き
		- const auto Pt0 = pos.piece_on(from);
		- const auto Pt = type_of(Pt0);
		- auto target2 = effects_from(Pt0, from, occ) & target;
		- MAKE_MOVE_TARGET(target2);
		+  const auto Pt = pos.piece_on(from);
		+  auto target2 = effects_from(Pt, from, occ) & target;
		+  MAKE_MOVE_TARGET_UNKNOWN(target2);
	
	あとQUIET_CHECKSか。そうか。

		-  case PRO_PAWN  :
		-  case PRO_LANCE :
		-  case PRO_KNIGHT:
		-  case PRO_SILVER:
		+  case PRO_PAWN  : GEN_MOVE_GOLD_CHECK     (PRO_PAWN  , goldEffect  ); break;
		+  case PRO_LANCE : GEN_MOVE_GOLD_CHECK     (PRO_LANCE , goldEffect  ); break;
		+  case PRO_KNIGHT: GEN_MOVE_GOLD_CHECK     (PRO_KNIGHT, goldEffect  ); break;
		+  case PRO_SILVER: GEN_MOVE_GOLD_CHECK     (PRO_SILVER, goldEffect  ); break;
		  case GOLD      : GEN_MOVE_GOLD_CHECK     (GOLD      , goldEffect  ); break;


		pseudo_legal()で落ちたときのデバッグ用のコード

            for (auto m2 : pv)
              cout << m2 << " ";
            cout << endl;

            if (!pos.pseudo_legal(m) || !pos.legal(m))
            {
              auto mg = MoveList<NON_EVASIONS>(pos);
              for (auto move : mg)
              {
                cout << move << " : " << Piece(move >> 16) << " : " ;
                if (!pos.pseudo_legal(move))
                  cout << "not pseudo_legal →　" << move;
                cout << endl;
              }

              cout << endl;
            }

			  if (!pos.pseudo_legal(move))
			  {
				cout << pos << move;
			  }

				秒読み300[ms]

				61.3%	
				#255
				やねうら王2016mid V323f gcc
				genmove修正。
				#254
				やねうら王2016mid V323e gcc
				戻した。

				111-1-70(0.1% R80.1)	

			ひどいバグであった模様。
			短い時間だと相対的にqsearch()の割合が高いために影響がもろに出るようだ。


			秒読み3000[ms]

			47.3%	
			#255
			やねうら王2016mid V323f gcc
			genmove修正。
			#0
			silent_majority_V1.1公式
			1スレッド

			214-13-238(88.0% R-18.5)	

		回数が少ないので何とも。たぶん互角ぐらい。
		10秒で魔女と丸1日回しておく。


			秒読み15000[ms]

			45.3%	
			#255
			やねうら王2016mid V323f gcc
			genmove修正。
			#0
			silent_majority_V1.1公式
			1スレッド

			505-63-611(99.9% R-33.1)	

	まだR33も離れているのか。evaluate()、AVX2化するわ。それでチャラだ。

] V3.22

・futilityとrazoringのパラメーター、元に戻してみる。

		秒読み3000[ms]

		49.7%	
		#246
		やねうら王2016mid V322a
		futilityとrazoringパラメーター戻した
		#0
		silent_majority_V1.1公式
		1スレッド

		357-24-361(57.4% R-1.9)	

	ほぼ互角。

	V3.22b
	LONG_EFFECT_LIBRARY利用でどれくらいの勝率になるのか。
	→　nps5%程度ダウン＋1手詰め発見率5%程度ダウンのコンボなので
	強くなるはずがないが…。1手詰めを3手詰めに変更するなら意味があるかも。
	
	long_effect.cpp、g++でbuild通らない。修正。

		long effect有効、gcc
		===========================
		Total time (ms) : 63803
		Nodes searched  : 42028435
		Nodes/second    : 658721

	そこまで遅くはない印象。

		秒読み3000[ms]

		45.6%	
		#247
		やねうら王2016mid V322b
		利き利用
		#0
		silent_majority_V1.1公式
		1スレッド

		169-12-202(96.1% R-31.0)	

	mate1()の発見率が5%落ちることと、nps 5%ダウン。結構勝率に影響するんだな…。
	同種ソフト対決なのも影響してるのかも知れないが。


		秒読み15000[ms]

		45.3%	
		#246
		やねうら王2016mid V322a
		futilityとrazoringパラメーター戻した
		#0
		silent_majority_V1.1公式
		1スレッド

		377-49-456(99.7% R-33.0)	

	まだ何らか負けているようだ。


	moved_piece_after()やめて、移動させる駒になっていてもどうせ歩のpromoteは除外されるので
	あまり変わらないのかも。桂を成る場合と成らない場合とが同一視されるのがちょっと嫌だな。
	やはり、魔女のこの部分の実装は良いとは思えないのだが…。


] V3.21

	V3.21a
・history、整理

		秒読み300[ms]

		51.8%	
		#242
		やねうら王2016mid V321a
		history整理
		#241
		やねうら王2016mid V321
		新基準

		298-6-277(17.9% R12.7)	


		秒読み10000[ms]

		50.0%	
		#243
		やねうら王2016mid V321b
		history整理
		#0
		silent_majority_V1.1公式
		1スレッド

		79-9-79(53.2% R0.0)	

		魔女と互角ぐらい？


移動させる駒にしたものと比較

	V3.21b

			#define USE_DROPBIT_IN_STATS
			#define KEEP_PIECE_IN_GENERATE_MOVES

		これ、USE_DROPBIT_IN_STATSをundefするとすごく弱くなる。(-R170ぐらい)
		何か修正忘れているのだと思う。この弱くなる原因をよく調べたほうがいい。

			  // Moveの上位16bitのvaridation
		#if 1
			  if (is_drop(move))
			  {
				if (move_dropped_piece(move) + Piece(pos.side_to_move()==BLACK ? 0 : PIECE_WHITE) + PIECE_DROP  != Piece(move >> 16))
				{
				  cout << pos << move << ":" << move_dropped_piece(move);

				}
			  } else if (!is_promote(move)) {
				if (pos.moved_piece_after_ex(move) != pos.piece_on(move_from(move)))
				{
				  cout << pos << move;
				}
			  } else {
				if (pos.moved_piece_after_ex(move) != pos.piece_on(move_from(move)) + PIECE_PROMOTE)
				{
				  cout << pos << move;
				}
			  }
		#endif


		→　わかった。move16_to_move()で復元するときに+32してしまっていた。これで範囲外の配列壊していたのか。

		  // moved_piece_before()の移動後の駒が返る版。
		  // KEEP_PIECE_IN_GENERATE_MOVESのときは単にmoveの上位16bitを返す。
		  Piece moved_piece_after(Move m) const {
		#ifdef    KEEP_PIECE_IN_GENERATE_MOVES
			// 上位16bitにそのまま格納されているはず。
		//    return Piece((m >> 16) & ~32); // DROP BITを飛ばす
			return Piece(m >> 16);
		#else
			return is_drop(m)
			  ? (move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE))
			  : is_promote(m) ? Piece(piece_on(move_from(m)) + PIECE_PROMOTE) : piece_on(move_from(m));
		#endif
		  }

		  moved_piece_after_ex()これ、要らないな。消そう。

		  pseudo_legal_s()でdropのとき+32してた。これか。

			rtime 100[ms]

			49.1%	
			#243
			やねうら王2016mid V321b
			history整理
			#242
			やねうら王2016mid V321a
			DROPBITなし

			279-6-289(67.8% R-6.1)	

	互角ぐらいになった。短い時間だとhistoryが小さくなるとCPU cacheの効率が良くなるからか？
	1000回ぐらいまわしてから判断しよう。

			rtime 1000[ms]

			50.2%	
			#242
			やねうら王2016mid V321a
			DROPBITなし
			#243
			やねうら王2016mid V321b
			history整理

			1084-47-1074(41.5% R1.6)	

	DROPBIT、やはりなくてもいいぐらいだな…。なしにする。

		秒読み10000[ms]

		47.6%	
		#244
		やねうら王2016mid V321a
		Dropなし、gcc
		#0
		silent_majority_V1.1公式
		1スレッド

		175-21-193(83.9% R-17.0)	

	まだわずかに負けているようだ。この原因をよく調べる。


■　2016/06/25

] V3.20

・PVの出力の抑制機能追加。(出力が詰まるため)

・新SEE周り、見直す。

		秒読み3000[ms]

		37.0%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		91-4-155(100.0% R-92.5)	

	新seeひどすぎ。

	旧see()、少し簡略化できた。

	新see()
	-		Bitboard occupied = pieces();
	+		Bitboard occupied;
	この初期化必要だった。


		秒読み500[ms]

		49.8%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		141-8-142(54.7% R-1.2)	


		秒読み3000[ms]

		57.5%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		61-2-45(4.9% R52.8)	

	→　新しいほうのsee()のほうがかなり優秀っぽい。前のsee()とは何だったのだ…。
	前のsee()バグっている可能性が微レ存。

	もう少し長い時間で実験してみる。

		秒読み5000[ms]

		51.3%	
		#236
		やねうら王2016mid V320a
		新see()
		#235
		やねうら王2016mid V320
		新基準

		471-23-448(21.4% R8.7)	

		強くはなっていそう。


	V3.20b

	    attackers = (stmAttackers | attackers_to(~stm, to, occupied)) & occupied;

	この & occupied、不要のはずなのだがこれを無くすとbenchの探索node数が変わる。おかしい。
	よく調べる。

		===========================
		Total time (ms) : 58766
		Nodes searched  : 34588434
		Nodes/second    : 588579

		gcc
		===========================
		Total time (ms) : 53064
		Nodes searched  : 34588434
		Nodes/second    : 651824

	→　理由わかった。KINGをcaptureしたときに、stmAttackersが有ることになってしまうから
	attackers & occupiedみたいな処理が必要になるのか。minAttackersでKINGを返すときに & occupied して返すべきなのか。
	(Aperyはそうなっている)	Stockfishのコードと等価にするにはいまのコードが正しいな。そうか…。

	Aperyのコードがわずかに無駄があるということなんだな。平岡さんに報告しよう。
	https://github.com/HiraokaTakuya/apery/issues/6

	see_sign()、いい加減にするのやめておいたほうがいいのでは…。

	#if 0
	  if (capture(move))
	  {
		// 捕獲する指し手で、移動元の駒の価値のほうが移動先の駒の価値より低い場合、これでプラスになるはず。
		// (取り返されたあとの成りを考慮しなければ)
		const Piece ptFrom = type_of(piece_on(move_from(move)));
		const Piece ptTo = type_of(piece_on(move_to(move)));
		if (CapturePieceValue[ptFrom] <= CapturePieceValue[ptTo])
		  return static_cast<Value>(1);
	  }
	#endif

		秒読み1000[ms]

		47.2%	
		#237
		やねうら王2016mid V320b
		新see()改良
		#236
		やねうら王2016mid V320a
		新see()

		258-6-289(91.4% R-19.7)	

	よくなってない。もう少し長い時間で回してみる。

		秒読み4000[ms]

		49.2%	
		#237
		やねうら王2016mid V320b
		新see()改良
		#236
		やねうら王2016mid V320a
		新see()

		127-11-131(62.2% R-5.4)	

	変わらず。Stockfishでもこの判定になっているから、ここ変えても変わらないのかも知れない。

	see_sign()の判定、kingでcaptureするときは常にプラスを返して良いのでは…。うーん..

    // KINGで取る手は合法手であるなら取り返されないということだから、ここではプラスを返して良い。
    // ゆえに、中盤用のCapturePieceValue[KING]はゼロを返して良いのでは。

	-   if (CapturePieceValue[ptFrom] <= CapturePieceValue[ptTo])
	+   if (CapturePieceValue[ptFrom] <= CapturePieceValue[ptTo] || ptFrom == KING)

	こうするか。

			秒読み300[ms]

			51.6%	
			#238
			やねうら王2016mid V320c
			新see()改良
			#236
			やねうら王2016mid V320a
			新see()

			489-11-458(14.9% R11.4)	

	勝率が上がったが、この実装おかしいなぁ…。

	CapturePieceValue、やはりKINGはゼロにするのが正しいのでは。

		// KINGの場合、プラスが返るが、その場合、moveは非合法手であるから、そのあと引っかかるはずなので
		// この判定、入れなくてもいいかも。
		//if (captured == KING)
		//  return Value(-CapturePieceValue[KING]);


		秒読み300[ms]

		51.3%	
		#239
		やねうら王2016mid V320d
		CapturePieceValue[KING]=0
		#238
		やねうら王2016mid V320c
		新see()改良

		401-11-381(22.6% R8.9)	

	弱くはなってなさそうなのでおk。

	gccでコンパイルして1手5秒で魔女と対戦させておく。

		秒読み5000[ms]

		50.0%	
		#240
		やねうら王2016mid V320d gcc
		CapturePieceValue[KING]=0
		#0
		silent_majority_V1.1公式
		1スレッド

		112-12-112(52.7% R0.0)	

	ほぼ互角っぽい。

		gcc PGO
		===========================
		Total time (ms) : 48621
		Nodes searched  : 32357232
		Nodes/second    : 665499

	1,2%速くなった程度？

	魔女と10秒でテスト。

		秒読み10000[ms]

		45.5%	
		#240
		やねうら王2016mid V320d gcc
		CapturePieceValue[KING]=0
		#0
		silent_majority_V1.1公式
		1スレッド

		438-52-525(99.8% R-31.5)	

	まだ少し負けているのか。

・ASSERT外して何故速くならないのか調べる。
	→　assert()、探索の時間のかかるところにはあまり入ってないからかな。
・プロファイラで調べる。
	
	Eval::calc_diff_kpp             40.29%
	Position::attackers_to          10.82%
	TranspositionTable::probe       10.81%
	is_mate_in_1ply                  3.79%
	MovePicker::generate_next_stage  2.69%

	なにこれ。
	評価関数40%でかすぎ。
	probe時間かかりすぎ。
	attackers_toも重すぎ。

	attackers_to、template<Color us>とかに分けるとか..。

	NullMoveのときにprefetchしたほうがいいのでは。
	misc.cppにprefetch追加。
	TTのfirst_entry()追加。
	→　どちらが速いかほぼ計測不能。

	利きを使わないmate1ply()はテーブル使ってもう少し速く出来るはず＆mate3にすれば
	もうちょっと強くなるはず。


■　2016/06/24

] V3.19

	gccでコンパイル
	===========================
	Total time (ms) : 48419
	Nodes searched  : 34145554
	Nodes/second    : 705209

	めっちゃ速くなった。AVX用のinclude header整理したのが良かったのか…？
	evaluate()でcompute_evalのときにSSE使えてなかったとか？	うーん。それが原因ではなさげなのだが。

	VC++2015
	===========================
	Total time (ms) : 52424
	Nodes searched  : 34145554
	Nodes/second    : 651334



■　2016/06/23

] V3.18

・mate間違う局面を見つけた。

	position startpos moves 7g7f 3c3d 6g6f 8c8d 7i6h 7a6b 5g5f 5c5d 3i4h 3a4b 4i5h 4a3b 5h6g 5a4a 6i7h 7c7d 6h7g 6b5c 2g2f 5d5e 5f5e 2b5e 2f2e 5c5d 5i6i 4b3c 4h5g 8b5b 6f6e 5d6e 5g6f 6e6f 7g6f 5e8b P*5e 4a3a S*8c 8b7a 8c7d+ 6a7b 6i7i 3a2b 8h7g 7b7c 7d7c 8a7c 7g6h 7c8e 8g8f P*7g 8i7g 8e7g+ 6h7g 7a3e G*4f 3e7a N*4e 3c4d 5e5d 5b5d 6f5e 5d7d 5e4d 4c4d S*6e 7d7b P*6b 7a6b 6e5d P*7e P*5c S*4c 5d4c 3b4c S*6a 7b7a 6a5b 4c5d 5b6c 7e7f 6g7f 7a7f 6c5d+ N*6f 2e2d 2c2d 7g6f 7f6f 5d4d B*5g P*6h P*6g 2h2d P*2c G*3c 2b3a N*4c 3a4a 3c3b 4a3b 2d3d

	静止探索絡みだな、これ。
	evasionですべての指し手を生成していない可能性とかも…。

	setoption name Threads value 1
	position startpos moves 7g7f 3c3d 6g6f 8c8d 7i6h 7a6b 5g5f 5c5d 3i4h 3a4b 4i5h 4a3b 5h6g 5a4a 6i7h 7c7d 6h7g 6b5c 2g2f 5d5e 5f5e 2b5e 2f2e 5c5d 5i6i 4b3c 4h5g 8b5b 6f6e 5d6e 5g6f 6e6f 7g6f 5e8b P*5e 4a3a S*8c 8b7a 8c7d+ 6a7b 6i7i 3a2b 8h7g 7b7c 7d7c 8a7c 7g6h 7c8e 8g8f P*7g 8i7g 8e7g+ 6h7g 7a3e G*4f 3e7a N*4e 3c4d 5e5d 5b5d 6f5e 5d7d 5e4d 4c4d S*6e 7d7b P*6b 7a6b 6e5d P*7e P*5c S*4c 5d4c 3b4c S*6a 7b7a 6a5b 4c5d 5b6c 7e7f 6g7f 7a7f 6c5d+ N*6f 2e2d 2c2d 7g6f 7f6f 5d4d B*5g P*6h P*6g 2h2d P*2c G*3c 2b3a N*4c 3a4a 3c3b 4a3b 2d3d
	go infinite

	利きを使わない1手詰め判定、バグがあった。とほほ。

	敵の合駒が歩以外にないという条件を間違えて自駒が歩以外ないという条件になっていた。とほほ。
	-  if (hand_count(ourHand , PAWN) == (int)ourHand)

		秒読み300[ms]

		48.4%	
		#231
		やねうら王2016mid V318
		mate1ply()バグ修正。
		#228
		やねうら王2016mid V317
		基準。

		266-7-284(79.1% R-11.4)	

	バグ取ったのに弱くなった気がする。
	razor margin変えたのとcheck_info_update()のタイミングが早くなったからか…。つらい..。

		秒読み300[ms]

		51.2%	
		#231
		やねうら王2016mid V318
		mate1ply()バグ修正。
		#228
		やねうら王2016mid V317
		基準。

		262-4-250(28.3% R8.1)	

	まあいいや、ほぼ互角ということで。

	V3.18a
	mate1ply()、ランダムプレイヤーでテストする。

	歩の移動による不成の王手による詰み、間違えてた。
		-    to = sq_king + (us == BLACK ? SQ_U : SQ_D);
		+    to = sq_king + (us == BLACK ? SQ_D : SQ_U);

	歩の移動による成りの王手による詰み、間違えてた。

		mate found = 10000 , mate miss = 89 , mate found rate  = 99.1179%
		mate found = 20000 , mate miss = 154 , mate found rate  = 99.2359%
		mate found = 30000 , mate miss = 235 , mate found rate  = 99.2228%
		mate found = 40000 , mate miss = 322 , mate found rate  = 99.2014%
		mate found = 50000 , mate miss = 438 , mate found rate  = 99.1316%
		mate found = 60000 , mate miss = 536 , mate found rate  = 99.1146%
		mate found = 70000 , mate miss = 632 , mate found rate  = 99.1052%
		mate found = 80000 , mate miss = 746 , mate found rate  = 99.0761%
		mate found = 90000 , mate miss = 854 , mate found rate  = 99.06%
		mate found = 100000 , mate miss = 940 , mate found rate  = 99.0688%

	いっぱい引っかかってワロタ。
	mate foundは99%付近か。利きによる詰みmate1ply()は93%ちょいだったのでかなりいいみたい…。

	こんな重大なバグ修正したのに0.3秒では差がほとんどつかない…。不思議なものだ。

		秒読み300[ms]

		50.5%	
		#232
		やねうら王2016mid V318a
		mate1ply()バグ修正。
		#230
		やねうら王2016mid V317b
		razoring改善。

		196-2-192(40.0% R3.6)	


		秒読み3000[ms]

		53.8%	
		#232
		やねうら王2016mid V318a
		mate1ply()バグ修正。
		#230
		やねうら王2016mid V317b
		razoring改善。

		98-5-84(13.3% R26.8)	
	
	長い時間になるにつれて、探索node数が増えるのでmate1ply()で間違う局面が増えるから、
	それによる負けが増える…はず。つまり長い時間においてはこれが差がつく一因であった…はず。


■　2016/06/22

] V3.17

・razoring margin 0.1秒で12時間ほどチューンして、そのあと秒数を広げながらチューンしなおして、
　最終的に強くなったかどうかを長い持ち時間で検証する。

	V3.17a

	・王手延長の単純化	
		-          || ( !moveCountPruning && pos.see_sign(move) >= VALUE_ZERO)))
		+          ||  pos.see_sign(move) >= VALUE_ZERO)))

	・IIDのとき、常にcut nodeにするのではなく、そのnodeのcutNodeを伝播させる
		-  search<NT>(pos, ss, alpha, beta, d, true);
		+  search<NT>(pos, ss, alpha, beta, d, cutNode);

			秒読み1000[ms]

			50.3%	
			#229
			やねうら王2016mid V317a
			simplify check extension
			#228
			やねうら王2016mid V317
			基準。

			332-13-328(42.3% R2.1)	

		ほぼ変わらない。簡単に計測できる量ではない。

	V3.17b
	PARAM_RAZORING_MARGIN4 : 570 → 586(53.33%) : ←←(値554,勝率49.96%,1872局,有意51.14%) ,←(値562,勝率49.35%,1872局,有意67.61%) ,→(値578,勝率50.77%,1872局,有意29.44%) ,→→(値586,勝率53.33%,1872局,有意0.97%) ,
	PARAM_RAZORING_MARGIN3 : 619 → 619(50.00%) : ←←(値603,勝率49.84%,1872局,有意54.54%) ,←(値611,勝率49.15%,1872局,有意72.51%) ,→(値627,勝率49.63%,1872局,有意60.14%) ,→→(値635,勝率49.23%,1872局,有意70.56%) ,
	PARAM_RAZORING_MARGIN2 : 578 → 578(50.00%) : ←←(値562,勝率49.39%,1872局,有意66.52%) ,←(値570,勝率50.65%,1872局,有意32.43%) ,→(値586,勝率49.76%,1872局,有意56.78%) ,→→(値594,勝率50.20%,1872局,有意44.35%) ,
	PARAM_RAZORING_MARGIN1 : 483 → 483(50.00%) : ←←(値467,勝率48.48%,3744局,有意90.41%) ,←(値475,勝率47.33%,1872局,有意96.98%) ,→(値491,勝率49.39%,1872局,有意66.54%) ,→→(値499,勝率50.61%,1872局,有意33.45%) ,

			秒読み1000[ms]

			51.4%	
			#230
			やねうら王2016mid V317b
			razoring改善。
			#228
			やねうら王2016mid V317
			基準。

			323-10-306(23.6% R9.4)	
	
	弱くはなっていなさそうなので良しとする。


] V3.16

	PARAM_RAZORING_MARGIN4 : 554 → 570(53.16%) : ←←(値538,勝率50.97%,1872局,有意24.74%) ,←(値546,勝率50.20%,1872局,有意44.35%) ,→(値562,勝率51.41%,3744局,有意11.27%) ,→→(値570,勝率53.16%,1872局,有意1.36%) ,
	PARAM_RAZORING_MARGIN3 : 603 → 619(52.31%) : ←←(値587,勝率49.16%,3744局,有意76.42%) ,←(値595,勝率49.56%,1872局,有意62.28%) ,→(値611,勝率50.08%,1872局,有意47.72%) ,→→(値619,勝率52.31%,3744局,有意2.39%) ,
	PARAM_RAZORING_MARGIN2 : 570 → 578(51.59%) : ←←(値554,勝率49.84%,1872局,有意54.53%) ,←(値562,勝率49.19%,3744局,有意75.71%) ,→(値578,勝率51.59%,3744局,有意8.56%) ,→→(値586,勝率44.50%,624局,有意99.73%) ,
	PARAM_RAZORING_MARGIN1 : 483 → 483(50.00%) : ←←(値467,勝率49.84%,1872局,有意54.54%) ,←(値475,勝率50.24%,1872局,有意43.21%) ,→(値491,勝率50.73%,1872局,有意30.43%) ,→→(値499,勝率50.65%,1872局,有意32.44%) ,

	assert外しても速くならないな…。
	VS2015、assertのマクロ、除去出来ていない可能性が..

		秒読み3000[ms]

		54.3%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		107-5-90(10.0% R30.1)	

	静止探索のcheck_info_update()、元の位置に戻してなかった。

		秒読み10000[ms]

		44.8%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		125-11-154(96.4% R-36.2)	

	差は縮まってきた。npsさえ出れば魔女には勝っているのでは。
	20秒でもテストしておく。

		秒読み20000[ms]

		50.5%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		49-4-48(42.0% R3.6)	

	ほぼ互角のようだ。よしよし。

	gcc用、コンパイルしなおした。

		秒読み3000[ms]

		52.4%	
		#228
		やねうら王2016mid V315gcc
		gccによるコンパイル
		#0
		silent_majority_V1.1公式
		1スレッド

		55-1-50(27.9% R16.6)	

	利きを求める部分以外はSSEなしでもなんとかなるかも知れないので、
	SSE2オプションを用意して準備をしていく。
	よく考えたらSSE4と4.1って別なのか。そうか…。
	SSE4用のオプションも用意する。
	これでSSE2用のバイナリがSSE2で動くかも。
	あとSSEなしでも動くかも。

	AperyのBitboardのoperator==()の実装、良くないのでGitHubで報告しておいた。

	EvalSumのnoSSE実装用意してなかった。用意する。
	というかUSE_AVX2でAVX2のコンストラクタ実装使っていなかった。
	
	EvalSum、eval/に移動。kppt_evalsumとリネーム

		VC++2015
		===========================
		Total time (ms) : 115619
		Nodes searched  : 72105321
		Nodes/second    : 623645

		gcc
		===========================
		Total time (ms) : 110433
		Nodes searched  : 72105321
		Nodes/second    : 652932

	やねうら王2016Mid、SSE42、SSE4、SSE2、noSSE用のバイナリも用意。

	ToDoより
	・ASSERT外してgccでビルドして2016 Midをリリース。
	→　した。
	・SSE2用バイナリを用意する。
	→　実験環境＆デバッグ環境がなくてよくわからない。
	→　とりあえずした。


■　2016/06/21

] V3.15

gcc 対応。__popcnt →　mm_popcnt_u64を使うと良いらしい。
	#include <nmmintrin.h>
	#define POPCNT32(a) _mm_popcnt_u64(a)
	#define POPCNT64(a) _mm_popcnt_u64(a)

		gcc
		===========================
		Total time (ms) : 128211
		Nodes searched  : 80011406
		Nodes/second    : 624060

		VC2015
		===========================
		Total time (ms) : 128684
		Nodes searched  : 80011406
		Nodes/second    : 621766

		何も変わってなかった。あれれ…。そして速くなっているな。
		FORCE_INLINEをつけた影響で少し速くなったのか？はてはて。

		BitboardのpopまわりにFORCE_INLINE追加した。
		movegen.cppにもFORCE_INLINE追加した。→　コンパイルがめっちゃ遅くなった。
		→　少し減らした。

		VC2015
		===========================
		Total time (ms) : 131980
		Nodes searched  : 80011406
		Nodes/second    : 606238

		gcc
		===========================
		Total time (ms) : 126935
		Nodes searched  : 80011406
		Nodes/second    : 630333

		gcc 仮想環境の外。4771
		===========================
		Total time (ms) : 122866
		Nodes searched  : 80011406
		Nodes/second    : 651208

		VC2015 仮想環境の外。4771
		===========================
		Total time (ms) : 125457
		Nodes searched  : 80011406
		Nodes/second    : 637759

		ASSERT外して、gccでコンパイルするか。
		gcc、もう少し速くなるかと思ったのだが…。


] V3.14

	1手0.5秒～3秒で簡単に調整できそうなパラメーターだけ自動調整してみる。
	調整したくないパラメーターはinterval = 9999に設定。

	まずはrazoring marginから。
	0.5秒で大雑把に調整して、そのあと秒数を増やしてみる。


		秒読み100[ms]

		50.4%	
		#227
		やねうら王2016mid V314slave
		slave。1スレッド
		#226
		やねうら王2016mid V314master
		master。1スレッド

		15558-418-15301(7.2% R2.9)	

	停止条件おかしくて止まってなかった。禿げる。



] V3.13

		秒読み400[ms]

		53.8%	
		#224
		やねうら王2016mid V313
		新基準。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		441-6-378(1.3% R26.8)	


	V3.13a
	search()でのevaluate()の呼び出しタイミング、やはり少し遅くしたほうが良いのでは..

		秒読み400[ms]

		48.8%	
		#225
		やねうら王2016mid V313a
		evaluate()遅延。1スレッド
		#224
		やねうら王2016mid V313
		新基準。1スレッド

		186-4-195(69.6% R-8.2)	

	計測不能な差のようなのでこれはいいや。



■　2016/06/20

] V3.12

	V3.12a
	 このkillerの設定、コメントアウトしたほうがいいかも。
	  {
        // IID、singular extension時であっても
        // killerがないときはkillerぐらいは登録したほうが少しだけ得。

        if (ss->killers[0] == MOVE_NONE)
          ss->killers[0] = move;
        else if (ss->killers[1] == MOVE_NONE)
          ss->killers[1] = move;
      }

		秒読み100[ms]

		54.7%	
		#222
		やねうら王2016mid V312a
		IID killerなし。1スレッド
		#221
		やねうら王2016mid V312
		新基準。1スレッド

		248-4-205(1.9% R33.1)	


		秒読み1000[ms]

		52.0%	
		#222
		やねうら王2016mid V312a
		IID killerなし。1スレッド
		#221
		やねうら王2016mid V312
		新基準。1スレッド

		640-27-591(8.1% R13.8)	

	IIDのkiller設定、よくないことがわかった。ばっさり消す。

	V3.12b
	・qsearch()を直接呼び出せるようにした。(学習で用いるので)
	書きかけ。まだ正しく動作しない。

	V3.12c
	ehashあり
		===========================
		Total time (ms) : 141850
		Nodes searched  : 80011406
		Nodes/second    : 564056

	ehashなし
		===========================
		Total time (ms) : 134267
		Nodes searched  : 80011406
		Nodes/second    : 595912

	なしのほうが速いっぽい。これは禿げる..。

	V3.12d
		if (!captureOrPawnPromotion && move != bestMove && quietCount < 64 - 4 + param1 * 4)
		param1 = 0..2
		10秒で魔女と回しておく。


		秒読み10000[ms]

		41.7%	38.6%	43.3%	
		#223
		やねうら王2016mid V312d
		quiet countテスト。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		123-17-172(99.8% R-58.2)	86-11-137(100.0% R-80.9)	97-10-127(98.1% R-46.8)	

		もう少しやらないと何とも…。


] V3.11

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
+      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
+      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。


	Core i7 4771k
	===========================
	Total time (ms) : 150870
	Nodes searched  : 92242005
	Nodes/second    : 611400


		秒読み1000[ms]

		59.5%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		94-5-64(0.7% R66.8)	


		秒読み3000[ms]

		41.4%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		96-10-136(99.7% R-60.5)	


	V3.11a
	historyでdropの+32をやめると？

		-      pc = Piece(pos.piece_on(sq) + (is_drop(move) ? 32 : 0));     \
		+      pc = Piece(pos.piece_on(sq) );     \

  Piece moved_piece_after_ex(Move m) const {
    return is_drop(m)
-      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) + 32)
+      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) /*+ 32*/)
      : is_promote(m) ? Piece(piece_on(move_from(m)) + PIECE_PROMOTE) : piece_on(move_from(m));
  }

-        Piece prevPc = pos.piece_on(prevSq) + Piece(is_drop((ss - 1)->currentMove) ? 32 : 0);
+       Piece prevPc = pos.piece_on(prevSq);


  これで互角なら、この処理なくしたい。
  Moveに移動させる駒が入っていれば、親nodeの移動させる駒が得られて、移動前の駒種でhistoryが
  引けて便利なのかも知れない。(cf. Apery)
  そこで強さに差が出ないなら、そのほうがシンプル。

		秒読み1000[ms]

		48.6%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		297-13-314(76.7% R-9.7)	

	誤差ぐらい。ここでわずかに良くとも、CPU cache汚染とかの問題があるので
	誤差ぐらいしか変わらないなら採用したくないのだが…。

		秒読み3000[ms]

		49.7%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		292-17-295(56.6% R-1.8)	

	ほぼ誤差だな。これは削除すべきか。そうか。

		  // 直前のnodeの指し手で動かした駒(移動後の駒)とその移動先の升を返す。
		  // この実装においてmoved_piece()は使えない。これは現在のPosition::side_to_move()の駒が返るからである。
		  // 駒打ちのときは、駒打ちの駒(+32した駒)が返る。
		#define sq_pc_from_move(sq,pc,move)                                \
			{                                                              \
			  sq = move_to(move);                                          \
			  pc = Piece(pos.piece_on(sq);     \
			}

	V3.11b
	ソースコード整理して、やねうら王2016 MidではUSE_DROPBIT_IN_STATSを使わないようにした。
	以前のバージョンより弱くなっていないかをテスト。

	history、移動前の駒で評価しても棋力変わらないのかも。
	指し手生成のときにmoveの上位bitを移動後の駒にするのは難しくはないのだが。
	というか、成りはquietではないのでhistoryからそもそも除外されているのか？
	除外は歩の成りだけか。うーん。角とか飛車の成り、本当に除外していいのか？
	価値上昇値が、歩の成りよりは低いか。	

		秒読み3000[ms]

		42.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		110-3-149(99.4% R-52.7)	

	あれ？めっちゃ弱くなった。どうなってんの…。

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。

	この省略が得していない？
	ああ、mate1ply()、置換表にhitしたときに省略されるのか。その差だな。
	修正して、再テスト。

		秒読み3000[ms]

		45.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		222-21-266(97.9% R-31.4)	

	やはり悪いのか…。そうなのか…。
	これは戻さざるをえない。

	V3.11c元に戻して0.3秒テスト。
	間違えてた。

		#ifndef USE_DROPBIT_IN_STATS   
			  pos.piece_on(prevSq);
		#else
			  pos.piece_on(prevSq) + Piece(is_drop((ss-1)->currentMove) ? 32 : 0);
		#endif

	こうだった。
	→　これで3.11と互角に戻った。再実験。

	V3.11d
		秒読み300[ms]

		48.3%	
		#214
		やねうら王2016mid V311d
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		703-21-752(90.1% R-11.7)	
	
	短い時間ではCPU cacheの汚染が少ないので勝ち越さなければならないのに
	勝っていないので、これは本当にダメそう。

	V3.11e
	MovePicker、killerの数に応じて、QUIET0,1,2,3とか分岐してはダメか？そこそこ意味があるような？
	Killer、Move32で持つの誤りだった。ExtMoveで持つべきだった。

		===========================
		Total time (ms) : 129748
		Nodes searched  : 74446076
		Nodes/second    : 573774

	比較実験しやすいようにdefineにする。

		// QUIETSの指し手を返すときに、分岐させて、少し高速化する。
		#define FAST_QUIETS

		===========================
		Total time (ms) : 130822
		Nodes searched  : 74446076
		Nodes/second    : 569063

	何も速くなってなかった。禿げた。
	killerまわり修正されたはずなのでV3.10と比較。

		秒読み300[ms]

		53.3%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		357-5-313(4.1% R22.8)	

		秒読み3000[ms]

		44.5%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-5-96(93.6% R-38.3)	
		あとはPGOとeval hashの差か。指し手生成で駒種格納。それからassert()消すと。


		秒読み10000[ms]

		44.7%	
		#215
		やねうら王2016mid V311e
		historyから駒打ち削除。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		209-28-259(99.1% R-37.3)	

		長い時間で勝率に差があったのは解消した。

	結論的には指し手生成段階で移動先での駒種 + 打ち駒なら32 をしたものを
	上位bitに格納したほうがいいのではということになった。

・moved_piece_after_exがいいどうか検討すべき。
	→　これやはり、それで正しい気がする。

	V3.11f
	aspirationのマージンを3秒で自動調整。

	        delta = Value(18 - 6 + 3 * param1);

	param1 = 0..4ぐらいで勝率を見る

		秒読み3000[ms]

		40.9%	46.8%	48.7%	47.4%	44.7%	
		#216
		やねうら王2016mid V311f
		aspiration調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		61-5-88(98.9% R-63.7)	36-1-41(75.3% R-22.6)	37-2-39(63.4% R-9.1)	36-2-40(71.7% R-18.3)	34-2-42(84.9% R-36.7)	

	V3.11g
	delta = Value(18 - 2 + 1 * param1);
	param1 = 0..4

		秒読み3000[ms]

		46.7%	48.0%	45.2%	51.3%	41.9%	
		#217
		やねうら王2016mid V311g
		aspiration調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		70-6-80(81.5% R-23.2)	72-6-78(71.6% R-13.9)	66-10-80(89.3% R-33.4)	78-4-74(34.3% R9.1)	62-4-86(98.0% R-56.8)	

	回数が少なくてよくわからない。


		// --- Counter Move

		// KEEP_PIECE_IN_COUNTER_MOVEがdefineされていたなら、
		// 移動させた駒を上位16bitに格納しておく。
		// bit24...16 = 移動させた駒(Piece。後手の駒含む)
		// bit15... 0 = 本来のMove

		#ifdef KEEP_PIECE_IN_COUNTER_MOVE
		#define COUNTER_MOVE Move32
		// 指し手の上位に駒種(移動前の駒)を格納してMove32化する。
		#define make_move32(move) ((Move32)((move) + (pos.moved_piece_after_ex(move) << 16)))
		#else
		#define COUNTER_MOVE Move 
		#endif

	このコード完全に削除して、Moveは32bit固定したほうがいいな。

		#ifndef KEEP_PIECE_IN_COUNTER_MOVE
			// しかし、Counter Moveの手は手番に関係ないので(駒種を保持していないなら)取り違える可能性があるため
			// (しかも、その可能性はそこそこ高い)、ここで合法性をチェックする必要がある。
			switch (pr)
			{
			case PAWN:
			case LANCE:
			  if ((us == BLACK && rank_of(to) == RANK_1) || (us == WHITE && rank_of(to) == RANK_9))
				return false;
			  break;
			case KNIGHT:
			  if ((us == BLACK && rank_of(to) < RANK_3) || (us == WHITE && rank_of(to) > RANK_7))
				return false;
			  break;
			}
		#else
			// 変な指し手を渡していないか、assertを入れて調べておく。(ASSERT_LV4以上のとき用)
			switch (pr)
			{
			case PAWN:
			case LANCE:
			  if ((us == BLACK && rank_of(to) == RANK_1) || (us == WHITE && rank_of(to) == RANK_9))
				ASSERT_LV4(false);
			  break;
			case KNIGHT:
			  if ((us == BLACK && rank_of(to) < RANK_3) || (us == WHITE && rank_of(to) > RANK_7))
				ASSERT_LV4(false);
			  break;
			}
		#endif

	V3.11h

	===========================
	Total time (ms) : 110191
	Nodes searched  : 62019533
	Nodes/second    : 562836

	何も速くなってない。なんなん…。

	まだいろいろ指し手生成にバグがあるようだ。
	random playerでデバッグ。

		#if 0
			  cout << pos;
			  for (auto m : mg)
			  {
				auto pc = pos.moved_piece_after_ex(m);
				cout << (Move)m << " " << pc << endl;
			  }
			  cout << endl;
		#endif

		  // ここで生成された指し手がすべて合法手であるかテストをする
		  for (auto m : mg)
		  {
			if (!pos.pseudo_legal(m))
			{
			  auto pc = pos.moved_piece_after_ex(m);
			  cout << pos << (Move)m << " " << pc;
			  pos.pseudo_legal(m);
			}

			ASSERT_LV3(pos.pseudo_legal(m));
			ASSERT_LV2(pos.legal(m));
		  }
		  →　やっとtest通った。

	===========================
	Total time (ms) : 185363
	Nodes searched  : 106442741
	Nodes/second    : 574239

	ほぼ高速化していないというのは指し手生成で余分なコストがかかった分を
	回収できていないのか。MovePickerはシンプルになったが…。

		秒読み100[ms]

		51.6%	
		#218
		やねうら王2016mid V311h
		指し手生成大改造。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		1079-34-1013(7.5% R11.0)	

	悪くはなっていなさそうなので良し。

	V3.11i
		piece_on()使っているところを置き換え。

	      Piece prevPc = pos.moved_piece_after_ex((ss - 1)->currentMove));

			秒読み100[ms]

			52.0%	
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド
			#210
			やねうら王2016mid V311
			新基準。1スレッド

			727-20-670(6.4% R14.2)	

	・clangでのコンパイル通るようにしてUbuntu×AWSで動くようにする。→　tanuki-さんにお願い中。
	→ 魔女ではgccでコンパイルするとVS2015でコンパイルするより15%ぐらい速くなる模様。
	→ gcc + PGOで1,2%ぐらい速くなる模様。VS2015のほうはちっとも..。
		gccでコンパイルしてリリースするか…。

	・classic-tceをビルドして、比較。
		classic-tceのほうがnpsが高い。
		Stockfish7でorderingがすこぶる重くなってnpsが下がったが、長い時間ではそちらのほうが良いようだ。

			秒読み100[ms]

			54.2%	
			#220
			やねうら王classic-tce V311i
			比較基準用。1スレッド
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド

			230-1-194(3.6% R29.6)	


			秒読み1000[ms]

			45.4%	
			#220
			やねうら王classic-tce V311i
			比較基準用。1スレッド
			#219
			やねうら王2016mid V311i
			指し手生成大改造。1スレッド

			108-5-130(93.2% R-32.2)	



■　2016/06/18

] PGO

・PGOかける

	Visual Studio Community 2015でK-Shogiをビルドしてみた
	http://blog.studiok-i.net/shogi/1272.html

		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択 ※XXXはプロジェクト名
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – インストルメント」を選択
		リビルドする
		「デバッグ」メニュー ⇒ 「デバッグの開始」
		適当に動かす（最適化してほしいところを集中的に動かすとよい）
		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – 最適化」を選択
		ビルドする（リビルドではない）

	PGO前
	===========================
	Total time (ms) : 126895
	Nodes searched  : 79320741
	Nodes/second    : 625089

	PGO後
	===========================
	Total time (ms) : 124923
	Nodes searched  : 79320741
	Nodes/second    : 634957

	1%ほどしか変わらない。おかしい…。仮想環境だからな..

] V3.10

	・5,10秒で魔女と対戦

	5秒→10秒で勝率が低下する。長い持ち時間になったときに勝率が低下するファクターが
	まだ何か残っているのだと思う。静止探索での一手詰めとかあのへん怪しい。
	assert復活させてPGOなしにしてもう少し実験せねば。

		秒読み5000[ms]
		38.8%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		85-7-134(100.0% R-79.1)	


		秒読み10000[ms]
		32.9%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		199-28-406(100.0% R-123.9)	

	利き更新なし＋1手詰めなしにしたときの10秒での勝率とほぼ変わらない。
	静止探索での1手詰めが長い持ち時間において足を引っ張っている気がする。
	しかし、静止探索のオーバーヘッドだけでそんなに勝率が変わるとは考えにくいので
	他の要因があるはず。

	5秒対戦だとnpsの差で負けている可能性とかもあって、原因がよくわからない。
	10秒対戦での勝率を見ながらチューンするしかない。

		
	短い時間では静止探索での1手詰めの効果は顕著なのだが…。

		秒読み100[ms]

		43.9%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		723-24-923(100.0% R-42.4)	



	静止探索での1手詰めを入れないと弱くなった。
	やはり意味があるように思える。

		秒読み10000[ms]

		27.0%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		31-1-84(100.0% R-173.2)	


	まさかと思うがONE_PLY = 1で試す。
	そうか。futility margin、ONE_PLYで割られていないのでONE_PLY = 2でやっていると
	半分の値でやっていることになるのか…そうか…。
	ならStockfishのfutility margin = 200は100相当なので、わりといまの値に近いのか…。


		秒読み100[ms]

		45.1%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		352-13-429(99.7% R-34.4)	

	少し弱くなった。ONE_PLYの値に影響を受けている何かがあるのか…。
	PGOの差かも知れない。reduction table絡みかも知れない。

		秒読み500[ms]

		49.8%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		138-1-139(54.8% R-1.3)	

	500[ms]だとほぼ変わらずっぽいのでONE_PLY=1のままちょっといろいろいじる。

	V3.10c
	reduction量を変えてみる。

		  for (int imp = 0; imp <= 1; ++imp)
			for (int d = 1; d < 64; ++d)
			  for (int mc = 1; mc < 64; ++mc)
			  {
				double r = log(d) * log(mc) / 2;
				if (r < 0.80)
				  continue;

				reduction_table[NonPV][imp][d][mc] = int(std::round(r)) * ONE_PLY;
				reduction_table[PV][imp][d][mc] = std::max(reduction_table[NonPV][imp][d][mc] - ONE_PLY, DEPTH_ZERO);

				if (!imp && reduction_table[NonPV][imp][d][mc] >= 2 * ONE_PLY)
				  reduction_table[NonPV][imp][d][mc] += ONE_PLY;
			  }

	ONE_PLY = 1と2の差は関係なくて、reductionテーブルは後者のほうが理想に近いのが、
	長時間において差が出る要因なのだろう…。ONE_PLY = 2のほうが各種パラメーターを
	調整しやすいので良いはずなのだが、現状、そこまで細かく調整する価値のあるパラメーターが
	なくて、ONE_PLYで割るコストのほうが高くついているのかも知れない。

		秒読み500[ms]

		49.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		276-8-286(67.9% R-6.2)	

	ほぼ互角。3秒でも変わらなければこちらを採用したほうが良いのでは…。


		秒読み3000[ms]
		59.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		65-3-45(2.2% R63.9)	

	どうも長い時間では新しいreduction tableのほうが有利くさい。(もう少しやったほうが良い)
	長い時間で魔女と勝率に差があく原因の一つはこれなのか？

	魔女と5秒でやらせてみる。


		秒読み5000[ms]

		31.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		66-9-146(100.0% R-137.9)	

	前よりたくさん負け越した。そんな馬鹿な…。
	この際、魔女に近づけて行って、勝率どこで回復するか見たほうが良いのでは..

	V3.10d
	LMR新テーブル + qsearchでのmateなしとのコンボ。
	
		秒読み5000[ms]

		31.7%	
		#196
		やねうら王2016mid V310d
		ONE_PLY=1,reduction変更,qmateなし。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		33-2-71(100.0% R-133.1)	

	よく見たら魔女もqsearchでmate1呼んでた。置換表に書き出していないが…。

	V3.10e
	qmate復活。qmateのタイミングをもう少し早めに変更。
	mate1を見つけたときに置換表に書き出す処理、やめる。

		秒読み5000[ms]

		29.4%	
		#197
		やねうら王2016mid V310e
		qmate復活。呼び出しタイミング調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		55-5-132(100.0% R-152.1)	

	どんどん弱くなっててワロタ。


	V3.10f
	aspirationの幅40->18,深さ7->5

		秒読み5000[ms]

		34.4%	
		#198
		やねうら王2016mid V310f
		aspiration幅変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-8-147(100.0% R-112.3)	

	aspirationまわり変えたら、少し強くなった。
	そうか。Apery向けのaspirationではないので少し損をしていたのか…。

	Aperyのコード以下の部分、fall throughなのか。怖すぎワロタ。
		switch (pos.isDraw(16)) {
		case NotRepetition      : if (!Signals.stop.load(std::memory_order_relaxed) && ss->ply <= MaxPly) { break; }
		case RepetitionDraw     : return ScoreDraw;

	V3.10g
	update_stats()するの、capture or pawn promotionであるべき。

	V3.10h
	すべて↑であるべき。


		秒読み5000[ms]

		36.4%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		68-2-119(100.0% R-97.2)	

	R15ぐらい違うのかな？

		秒読み10000[ms]

		34.7%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		114-14-215(100.0% R-110.2)	

	10秒でもそんなにRは下がらなくなってきた。よしよし。


	USE_DROPBIT_IN_STATS、もしかして無駄である可能性…。
	まあいいや。いまそこが問題ではない。

	あとどこだろ。

	・指し手生成で何か抜けている可能性
	→　quiet + capture = all になるかとかテストすべき。

	・SEE()がおかしい可能性
	→　簡単な探索部と合致するかテストすべき

	・新しく書いたmate1ply()がおかしい可能性
	・評価関数が重い可能性
	
	V3.10i
	利き有効にしてのmate1ply()

		秒読み1000[ms]

		49.4%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		170-6-174(60.6% R-4.0)	


		秒読み3000[ms]

		42.0%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		42-4-58(95.6% R-56.1)	

	はやり遅い分だけやや損なのかも。

	see()書きなおしてみるか。

	V3.10j
	USE_SIMPLE_SEEを用意した。

		bench
		===========================
		Total time (ms) : 442722
		Nodes searched  : 308535061
		Nodes/second    : 696904

	だいぶ速くなった気がする。
	SEE、もう少し速くできる気がする。

		秒読み1000[ms]

		6.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		2-0-28(100.0% R-458.5)	

	20連敗した。SEE、これじゃない感。

	turn間違えてる。
	  Color turn = ~(is_drop(move) ? sideToMove : color_of(piece_on(move_from(move))));
	いま、seeの順番、金があとになってるのよくない気はする。
	あと、攻撃の有無間違えてた。あれだけでこんなに勝率下がるのか。そうか…。

		秒読み100[ms]

		22.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		20-0-68(100.0% R-212.6)	

	めっちゃ弱くなっとる。よく調べる。
	see()の前提処理まちごてた。修正した。

	see()前のコードも最後KING+1を返しているの、これおかしい気がしてきた。そうか…。
	と金で何かを取るとき、これがKING扱いになっていたのか。修正した。

		===========================
		Total time (ms) : 189502
		Nodes searched  : 108434227
		Nodes/second    : 572206

	
		秒読み300[ms]

		39.3%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		132-5-204(100.0% R-75.6)	

	新SEE、バグってるんやろか。元のSEEに戻してテスト。

	V3.10k

		秒読み300[ms]

		49.8%	
		#203
		やねうら王2016mid V310k
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		311-10-313(54.8% R-1.1)	

	SEE直したはずなのだが、勝率に影響がない。そんなもんなのか…。
	
	min_attacker()さらになおした。orderingも改善したはず…だが？

	V3.10l

		// 歩、香、桂、銀、金、角、飛…の順で取るのに使う駒を調べる。

		Bitboard b;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_PAWN  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_LANCE ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_KNIGHT][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_SILVER][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_GOLD  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm] | pos.king_square(stm)); if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm] | pos.king_square(stm)); if (b) goto found;

		// ここでサイクルは停止するのだ。
	#ifndef USE_SIMPLE_SEE
		uncapValue = VALUE_ZERO;
	#endif
		return KING;

	わりとわかりやすい気がする。


		秒読み300[ms]

		48.7%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		364-13-383(76.8% R-8.8)	

	わずかに遅くなった分、回収できていないのか…？

	// この駒が成れるなら、成りの値を返すべき。
	// ※　最後にこの地点に残る駒を返すべきなのか。相手が取る/取らないを選択するので。
	Piece pt = type_of(pos.piece_on(sq));
	if (!(pt & PIECE_PROMOTE) && (pt != GOLD)
		&& (canPromote(stm, to) || canPromote(stm,sq)))
		// 成りは敵陣へと、敵陣からの二種類あるので…。
	{

#ifndef USE_SIMPLE_SEE
		uncapValue = ProDiffPieceValue[pt]; // この駒が取り返せなかったときこの分、最後に損をする。
#endif
		return pt;
	}

	→　ちゃんと書いた。

		秒読み300[ms]

		50.0%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		525-19-524(48.8% R0.3)	

	やっと前のものと等価ぐらいになった。

	新see()なおってたりしないのか。
	V3.10m

		秒読み300[ms]

		41.8%	
		#205
		やねうら王2016mid V310m
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		147-5-205(99.9% R-57.8)	

	落ちなくはなったが弱い。まだ何かバグがある模様。
	まあいいや。これはまた時間あるときにデバッグしよう。
	
	V3.10n
	futility margin = 200など

		秒読み3000[ms]

		42.1%	
		#206
		やねうら王2016mid V310n
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		174-12-239(99.9% R-55.1)	

	差が縮まってきた…？

	V3.10o

	// 捕獲から逃れる指し手はreduction量を減らす。
	→　これ意味不明だった。どういうトリックかよくわからない。
	これ、コメントアウトしたほうがよさげ。
	see()の仕様がこちらの想定と違うのだが、それを考慮しても、
	Stockfishのコードはバグっているとしか思えない。

	null moveのreduction等を戻す。

		秒読み3000[ms]

		41.8%	
		#207
		やねうら王2016mid V310o
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		46-2-64(96.5% R-57.4)	


	V3.10p

-        pv[0] = MOVE_NONE;
+        (ss+1)->pv[0] = MOVE_NONE;

	なんぞこれ。間違えてた。

	魔女、fail lowたときに直前の指し手にボーナスを与える条件、間違っているような…。
		else if (depth >= 3 * OnePly
		  && bestMove.isNone() //!bestMove
		  && !inCheck
-		  && !ttMove.isCapture()//!move.cap()
+		  && !pos.captured_piece_type()
		  && (ss-1)->currentMove.is_ok())

	historyのupdateで打ち駒を+32してないところがあった。修正した。
	
	魔女より15%ぐらい遅いのかも知れない。(R40相当？)
	評価関数の差分計算とMoveの構造体、考えなおしたほうがよさ気。

		秒読み3000[ms]

		43.9%	
		#208
		やねうら王2016mid V310p
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		47-5-60(91.2% R-42.4)	

	npsの差程度に落ち着いてきた？寝る前に10秒で回しておく。
	せっかくなのでfutilityの幅を変える実験でもしておく。

	V3.10q
		  Value futility_margin(Depth d, int game_ply) {
			return Value(d * (PARAM_FUTILITY_MARGIN_ALPHA + param1 * 10 - 20) / ONE_PLY);
		  }

	Move32bit化、bit layout考えなおしたほうがよさ気。
	移動させる駒、上位16bitに格納するなら、駒打ちをそのbit5に格納したほうがいいような。
	historyで打ち駒を本当に分けたほうがいいのかはよくわからないが。
	historyにおいて、移動させる元の駒でorderingすべきなのか、そのあとの駒でorderingすべきか。
	指し手生成のときにそこまで生成すべきかどうか悩むな。


		秒読み10000[ms]

		41.1%	37.2%	37.5%	36.3%	39.6%	
		#209
		やねうら王2016mid V310q
		futility実験。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		129-18-185(99.9% R-62.6)	110-16-186(100.0% R-91.2)	112-13-187(100.0% R-89.0)	110-9-193(100.0% R-97.7)	120-9-183(100.0% R-73.3)	

	futility margin 180にしておくか。

